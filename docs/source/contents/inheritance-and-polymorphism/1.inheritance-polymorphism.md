---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---


# Instance-level data

+ Let's see how we can distinguish {ref}`Instance-level<contents/inheritance-and-polymorphism/1.inheritance-polymorphism.md#instance-level-data>`
data and {ref}`Class-level<contents/inheritance-and-polymorphism/1.inheritance-polymorphism.md#class-level-data>` data.

+ The following code has `name` and `salary` as attributes, with specific values for each new instance of the class.
They are called `instance attributes`

```{thebe-button} 
```

``````{list-table}
:header-rows: 1
:widths: 20 15

* - Instance-level Data
  - Notes
* - ````{container} thebe
    ```{code-block}
    :class: thebe 
    class Employee:
      def __init__(self, name, salary):
        self.name = name
        self.salary = salary
    
    emp1 = Employee("Poor Guy", 30000)
    emp2 = Employee("You my friend", 100000) 
    print(emp1.name + ': ' + str(emp1.salary))
    print(emp2.name + ': ' + str(emp2.salary))
    ```
    ````
    
  - + `name`, `salary` are instance attributes
    + `self` binds to an instance 
    
``````

# Class-level data

+ But now, we want to store some data that is shared among all the instances. 

+ For example, we can introduce a minimal salary across the entire organization. In other words,
the data should not differ among object instances. So we can define `class attributes` in the 
body of `class`. That `class attribute` will serve as a `global variable` within a class.


```{thebe-button} 
```

``````{list-table}
:header-rows: 1
:widths: 20 15

* - Class-level Data
  - Notes
* - ````{container} thebe
    ```{code-block}
    :class: thebe 
    class Employee:
        # Define a `class attribute`
        MIN_SALARY = 30000
        def __init__(self, name, salary):
            self.name = name
            #-------------------------#
            # Use class name to access 
            # class attribute
            #------------------------#
            if salary >= Employee.MIN_SALARY:
                self.salary = salary
            else:
                self.salary = Employee.MIN_SALARY
    
    emp1 = Employee("Poor Guy", 40000)
    emp2 = Employee("You my friend", 120000) 
    print(emp1.name + ': ' + str(emp1.MIN_SALARY))
    print(emp2.name + ': ' + str(emp2.MIN_SALARY))
    ```
    ````
    
  - + `MIN_SALARY` is shared among all instance 
    + {octicon}`alert;1em;sd-text-info` `self` is not used to define class attributes.
    + use `ClassName.ATTR_NAME` to access the `class attribute` value.
    
``````

+ The benefit of using `class attributes` is to have global constants that are related to class,
for example `min` and `max` values for attributes, or commonly used values and constants, e.g. `pi`. 


# Class Methods

+ Regular `methods` are already shared between instances. The same code gets executed for every `instance`.
The only difference is the data that is fed into it. 

+ It is possible to define methods bound to class rather than an instance. But these methods will not 
be able to use any `instance-level` data.

+ To define a `class-method` , we have to start with a `classmethod` decorator, followed by a method definition. The only
difference is that now the first argument is not `self`, but `cls`, referring to the class, just like the self argument
was a reference to a particular instance.  


```python
class MyClass:
    
    @classmethod                               # --> use decorator to declare a class method
    def my_method(cls,argument_1,argument_2):  # --> `cls` argument refers to the class

MyClass.my_method(argument_1,argument_2)       # --> class-dot-method syntax
```

+ A class can only have one `__init__` method, but there might be multiple ways to initialize an object. 

+ For example, if you want to create an `Employee` object from data stored in a file, we can't use a method. This would
require an instance, and there isn't one yet. So, we can create a `class-method` that accepts a file name, reads the first
line from the file that contains the name of the employee, and returns an object instance.

## Example - Class Method 1
```{code-cell} python3

class Employee:
    MIN_SALARY = 30000
    def __init__(self, name, salary=30000):
        self.name = name
        if salary >= Employee.MIN_SALARY:
            self.salary = salary
        else:
            self.salary = Employee.MIN_SALARY
    @classmethod
    def from_file(cls,filename):
        with open(filename,"r") as f:
            name = f.readline()
        return cls(name)


emp1 = Employee("fernando", 500000)
print(type(emp1))
print(emp1.name, str(emp1.salary))

# TODO - Find a way to load a file from here
#emp2 = Employee.from_file("")
#print(type(emp2))
#print(emp2.name, str(emp2.salary))

```


## Example - Class Method 2

+ Let's create a `constructor` = `__init__` that creates BetterDate objects given the values for `year`
`month`, and `day`. But we can also create a `BetterDate` objects from `strings` and `datetime`.

```{thebe-button} 
```

````{container} thebe
```{code-block}
:class: thebe
from datetime import datetime
 
class BetterDate:
    # Constructor
    def __init__(self, year, month, day):
        self.year, self.month, self.day = year, month, day

    # Define a class method from_str
    @classmethod
    def from_str(cls, datestr):
        # Split the string at "-" and convert each part to integer
        parts = datestr.split("-")
        year, month, day = int(parts[0]), int(parts[1]), int(parts[2])
        # Return the class instance
        return cls(year, month, day)

    @classmethod
    def from_datetime(cls, datetime):
        return cls(datetime.year, datetime.month, datetime.day)


# Constructor able to create `BetterDate` objects froms strings
bd = BetterDate.from_str('2050-01-01')
print('!' + '-'*70)
print("BetterDate objects from strings:")
print(bd.year, bd.month, bd.day)
print(bd.__dict__)
print('!'+ '-'*70)

# BetterDate objets given values of year, month, day
bd2 = BetterDate(year=2022, month = 2, day =22)
print("`BetterDate` objects from year, month, day:")
print(bd2.year, bd2.month, bd2.day)
print(bd2.__dict__)
print('!' + '-'*70)

# BetterDate objects from datetime objects
today = datetime.today()
bd3 = BetterDate.from_datetime(today) 
print("`BetterDate` objects from datetime:")
print(bd3.year, bd3.month, bd3.day)
print(bd3.__dict__)
print('!' + '-'*70)
```

```{container} output
!----------------------------------------------------------------------  
`BetterDate` objects from `strings`:  
2050 1 1  
{'year': 2050, 'month': 1, 'day': 1}  
!----------------------------------------------------------------------  
`BetterDate` objects from `year`, `month`, `day`:  
2022 2 22  
{'year': 2022, 'month': 2, 'day': 22}  
!----------------------------------------------------------------------  
`BetterDate` objects from `datetime`:  
2022 4 19  
{'year': 2022, 'month': 4, 'day': 19}  
!----------------------------------------------------------------------  
```
````

# Inheritance 
[See Reference here](https://pythonnumericalmethods.berkeley.edu/notebooks/chapter07.03-Inheritance-Encapsulation-and-Polymorphism.html#inheritance)

+ Inheritance allows us to define a class that inherits all the methods and attributes from another class.

+ The code below has a class `Sensor` with attributes `name`, `location`, and `record_date` that pass from the creation
of an object and an attribute `data` as an empty dictionary to store data.  The method `add_data` contains `t` and `data`
as input parameters to take in timestamp and data arrays. Within this method, we also assign `t` and `data` to the
`self.data` attribute with `time` and `data` as the `` [`keys`] ``. The method `clear_data` is created to delete
the data.

```{thebe-button} 
```

````{container} thebe
```{code-block}
:class: thebe
import numpy as np 
class Sensor():
    def __init__(self, name, location, record_date):
        self.name = name
        self.location = location
        self.record_date = record_date
        self.data = {}
        
    def add_data(self, t, data):
        self.data['time'] = t
        self.data['data'] = data
        print(f'We have {len(data)} points saved')        
        
    def clear_data(self):
        self.data = {}
        print('Data cleared!')

if __name__ == "__main__":
  sensor1 = Sensor('sensor1', 'Berkeley', '2019-01-01')
  data = np.random.randint(-10, 10, 10)
  sensor1.add_data(np.arange(10), data)
  print(sensor1.data)


```
````
