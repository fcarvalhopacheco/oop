# Operator overloading

+ How can we compare two custom objects? 
+ Below we have two objects of the `Sensor` class that have the same data. if we Python ask if these objects are equal 
, the answer is `no`. 


    ```{thebe-button} 
    ```

    ````{container} thebe
    ```{code-block}
    :class: thebe, thebe-init
    class Sensor:
        
        def __init__ (self, name, serial_number):
        
            self.name , self.serial_number = name, serial_number
            

    sensor1 = Sensor("Temperature",123)
    sensor2 = Sensor("Temperature",123)

    sensor1 == sensor2 
    ```

    ``` {container} output
    False
    ```

    ````

    ```{important}
    Python doesn't consider two objects with the same data equal by default. 
    ```


+ When we print both sensors, we receive an output with `Sensor at` and a string (a number in hexadecimal). When an 
object is created, Python allocates a chunk of memory to that object, and the variable that the object is assigned to
actually contains just the reference to the memory chunk. 

+ In other words, the code below is saying to Python: Allocate a chunk of memory for a sensor object, and label it 
`sensor1`. Then, allocate another chunk of memory, and label it `sensor2`. 

    ```{note}
    When we compare variables `sensor1` and `sensor2`, we are actually comparing references, not the data. Because `sensor1`
    and `sensor2` point to different chuncks in memory, they are not considered equal.
    ```

    ```{thebe-button} 
    ```

    ````{container} thebe
    ```{code-block}
    :class: thebe, thebe-init
    sensor1 = Sensor("Temperature",123)
    sensor2 = Sensor("Temperature",123)

    print(sensor1)
    print(sensor2)
    ```

    ```{container} output
    <__main__.Sensor object at 0x7fecb45d2790>  
    <__main__.Sensor object at 0x7fecb45d2a60>  
    ```

    ````


## Comparison: `__eq__()`

+ The `__eq__()` method is implicitly called whenever two objects of the same class are compared to each other.
+ We can re-define this method to execute custom comparison code. The methods should accept two arguments, referring to
the objects to be compared. They are usually `self` and other by convention. It should always return a `Boolean` value
`True` or `False`.

+ The following code has a basic `Sensor` class with `id` and `name` attributes, and we redefine the `__eq__` method to 
return `True` if the values of all attributes are equal. 

    ```{thebe-button} 
    ```

    ````{container} thebe
    ```{code-block}
    :class: thebe, thebe-init
    class Sensor: 

        def __init__(self, id, name):
            self.id, self.name = id, name
            
        # The following is called when `==` is used
        def __eq__(self, other):
            print ("__eq__() is called")
            
            # Return `True` if all attributes match
            return (self.id == other.id) and \
                (self.name == other.name)

    sensor3 = Sensor(456, "Conductivity")
    sensor4 = Sensor(456, "Conductivity")

    sensor3 == sensor4
    ```

    ```{container} output
    `__eq__()` is called  
    True  
    ```
    ````


## Other Comparison Operators

+ Python allows you to implement all the comparison operators in your custom class using special methods like `__eq__`.



| Operator |        Method         |                                         Description                                          | Example | 
|----------|:---------------------:|:--------------------------------------------------------------------------------------------:|:--------|
| ==       | `__eq__`(self, other) |                   returns True if two operands are equal, otherwise False.                   | a == b  |
| !=       | `__ne__`(self, other) |                 returns True if two operands are not equal, otherwise False.                 | a != b  |
| >        | `__gt__`(self, other) |       returns True if left operand is greater than the right operand, otherwise False        | a > b   |
| <        | `__lt__`(self, other) |       returns True if left operand is smaller than the right operand, otherwise False        | a < b   |
| >=       | `__ge__`(self, other) | returns True if left operand is greater than or equal to the right operand, otherwise False  | a >= b  |
| <=       | `__le__`(self, other) | returns True if left operand is smaller than or equal to the right operand, otherwise False. | a <= b  |



### Example - Comparison Operators 1

```{thebe-button} 
```

````{container} thebe
```{code-block}
:class: thebe, thebe-init
class Data:
    id = 0

    def __init__(self, i):
        self.id = i

    def __eq__(self, other):
        print('== operator overloaded')
        if isinstance(other, Data):
            return True if self.id == other.id else False
        else:
            return False

    def __ne__(self, other):
        print('!= operator overloaded')
        if isinstance(other, Data):
            return True if self.id != other.id else False
        else:
            return False

    def __gt__(self, other):
        print('> operator overloaded')
        if isinstance(other, Data):
            return True if self.id > other.id else False
        else:
            return False

    def __lt__(self, other):
        print('< operator overloaded')
        if isinstance(other, Data):
            return True if self.id < other.id else False
        else:
            return False

    def __le__(self, other):
        print('<= operator overloaded')
        if isinstance(other, Data):
            return True if self.id <= other.id else False
        else:
            return False

    def __ge__(self, other):
        print('>= operator overloaded')
        if isinstance(other, Data):
            return True if self.id >= other.id else False
        else:
            return False


d1 = Data(10)
d2 = Data(7)

print(f'd1 == d2 = {d1 == d2}')
print(f'd1 != d2 = {d1 != d2}')
print(f'd1 > d2 = {d1 > d2}')
print(f'd1 < d2 = {d1 < d2}')
print(f'd1 <= d2 = {d1 <= d2}')
print(f'd1 >= d2 = {d1 >= d2}')
```
````
