# Operator overloading

+ How can we compare two custom objects? 
+ Below we have two objects of the `Sensor` class that have the same data. if we Python ask if these objects are equal 
, the answer is `no`. 


    ```{thebe-button} 
    ```

    ````{container} thebe
    ```{code-block}
    :class: thebe, thebe-init
    class Sensor:
        
        def __init__ (self, name, serial_number):
        
            self.name , self.serial_number = name, serial_number
            

    sensor1 = Sensor("Temperature",123)
    sensor2 = Sensor("Temperature",123)

    sensor1 == sensor2 
    ```

    ``` {container} output
    False
    ```

    ````

    ```{important}
    Python doesn't consider two objects with the same data equal by default. 
    ```


+ When we print both sensors, we receive an output with `Sensor at` and a string (a number in hexadecimal). When an 
object is created, Python allocates a chunk of memory to that object, and the variable that the object is assigned to
actually contains just the reference to the memory chunk. 

+ In other words, the code below is saying to Python: Allocate a chunk of memory for a sensor object, and label it 
`sensor1`. Then, allocate another chunk of memory, and label it `sensor2`. 

    ```{note}
    When we compare variables `sensor1` and `sensor2`, we are actually comparing references, not the data. Because `sensor1`
    and `sensor2` point to different chuncks in memory, they are not considered equal.
    ```

    ```{thebe-button} 
    ```

    ````{container} thebe
    ```{code-block}
    :class: thebe, thebe-init
    sensor1 = Sensor("Temperature",123)
    sensor2 = Sensor("Temperature",123)

    print(sensor1)
    print(sensor2)
    ```

    ```{container} output
    <__main__.Sensor object at 0x7fecb45d2790>  
    <__main__.Sensor object at 0x7fecb45d2a60>  
    ```

    ````


## Comparison: `__eq__()`

+ The `__eq__()` method is implicitly called whenever two objects of the same class are compared to each other.
+ We can re-define this method to execute custom comparison code. The methods should accept two arguments, referring to
the objects to be compared. They are usually `self` and other by convention. It should always return a `Boolean` value
`True` or `False`.

+ The following code has a basic `Sensor` class with `id` and `name` attributes, and we redefine the `__eq__` method to 
return `True` if the values of all attributes are equal. 

    ```{thebe-button} 
    ```

    ````{container} thebe
    ```{code-block}
    :class: thebe, thebe-init
    class Sensor: 

        def __init__(self, id, name):
            self.id, self.name = id, name
            
        # The following is called when `==` is used
        def __eq__(self, other):
            print ("__eq__() is called")
            
            # Return `True` if all attributes match
            return (self.id == other.id) and \
                (self.name == other.name)

    sensor3 = Sensor(456, "Conductivity")
    sensor4 = Sensor(456, "Conductivity")

    sensor3 == sensor4
    ```

    ```{container} output
    `__eq__()` is called  
    True  
    ```
    ````


## Other Comparison Operators

+ Python allows you to implement all the comparison operators in your custom class using special methods like `__eq__`.



| Operator |        Method         |                                         Description                                          | Example | 
|----------|:---------------------:|:--------------------------------------------------------------------------------------------:|:--------|
| ==       | `__eq__`(self, other) |                   returns True if two operands are equal, otherwise False.                   | a == b  |
| !=       | `__ne__`(self, other) |                 returns True if two operands are not equal, otherwise False.                 | a != b  |
| >        | `__gt__`(self, other) |       returns True if left operand is greater than the right operand, otherwise False        | a > b   |
| <        | `__lt__`(self, other) |       returns True if left operand is smaller than the right operand, otherwise False        | a < b   |
| >=       | `__ge__`(self, other) | returns True if left operand is greater than or equal to the right operand, otherwise False  | a >= b  |
| <=       | `__le__`(self, other) | returns True if left operand is smaller than or equal to the right operand, otherwise False. | a <= b  |



### Example - Comparison Operators 1

```{thebe-button} 
```

````{container} thebe
```{code-block}
:class: thebe, thebe-init
class Data:
    id = 0

    def __init__(self, i):
        self.id = i

    def __eq__(self, other):
        print('== operator overloaded')
        if isinstance(other, Data):
            return True if self.id == other.id else False
        else:
            return False

    def __ne__(self, other):
        print('!= operator overloaded')
        if isinstance(other, Data):
            return True if self.id != other.id else False
        else:
            return False

    def __gt__(self, other):
        print('> operator overloaded')
        if isinstance(other, Data):
            return True if self.id > other.id else False
        else:
            return False

    def __lt__(self, other):
        print('< operator overloaded')
        if isinstance(other, Data):
            return True if self.id < other.id else False
        else:
            return False

    def __le__(self, other):
        print('<= operator overloaded')
        if isinstance(other, Data):
            return True if self.id <= other.id else False
        else:
            return False

    def __ge__(self, other):
        print('>= operator overloaded')
        if isinstance(other, Data):
            return True if self.id >= other.id else False
        else:
            return False


d1 = Data(10)
d2 = Data(7)

print(f'd1 == d2 = {d1 == d2}')
print(f'd1 != d2 = {d1 != d2}')
print(f'd1 > d2 = {d1 > d2}')
print(f'd1 < d2 = {d1 < d2}')
print(f'd1 <= d2 = {d1 <= d2}')
print(f'd1 >= d2 = {d1 >= d2}')
```
````


### Example - Comparison Operators 2

+ It is a good practice to check the class of objects passed to `__eq__()` method to make sure the comparison makes
sense.


+ For example, consider the following two classes: 

```{thebe-button} 
```

``````{list-table}
:header-rows: 1
:widths: 20 20

* - Temperature class
  - Conductivity Class
* - ````{container} thebe
    ```{code-block}
    :class: thebe, thebe-init
    class Temperature :
      def __init__(self, number):
         self.number = number

      def __eq__(self, other):
        return self.number == other.number

    temp = Temperature(1453)
    print(type(temp))
    ```
    ````
    
  - ````{container} thebe
    ```{code-block}
    :class: thebe, thebe-init
    class Conductivity:
      def __init__(self, number):
         self.number = number

      def __eq__(self, other):
        return self.number == other.number

    cond = Conductivity(1453) 
    print(type(cond))
    ```
    ````
``````


+ Running `temp == cond` will return `True`, even though we are comparing a temperature sensor number with a 
conductivity sensor number. This is wrong! We need to compare potatoes with potatoes =) 


```{thebe-button} 
```

::::{grid} 2
:::{grid-item-card} **BAD !!!**: 
:columns: 12
````{container} thebe
```{code-block}
:class: thebe, thebe-init

temp = Temperature(1453)
cond = Conductivity(1453) 
print(temp == cond)
```
```{container} output
True
```

````
:::
:::{grid-item-card}  **GOOD !**:
:columns: 12

````{container} thebe
```{code-block}
:class: thebe, thebe-init
class Conductivity:
  def __init__(self, number):
    self.number = number

  def __eq__(self, other):
    return True if (self.number == other.number) and \
                   isinstance(other, Conductivity) else False

class Temperature:
  def __init__(self, number):
    self.number = number

  def __eq__(self, other):
    return True if (self.number == other.number) and \
                   isinstance(other, Temperature) else False

# ----------------------------------- %
temp1 = Temperature(1453)
cond1 = Conductivity(1453) 
print (temp1.number, cond1.number)
print(f'temp1 == cond1 = {temp1 == cond1}')
# ------------------------------------ %
temp2 = Temperature(1453)
print (temp1.number, temp1.number)
print(f'temp1 == temp2 = {temp1 == temp2}')
# ------------------------------------ %
temp3 = Temperature(3985)
print (temp1.number, temp3.number)
print(f'temp1 == temp3 = {temp1 == temp3}')
# ------------------------------------ %
cond2 = Conductivity(5050)
print (cond1.number, cond2.number)
print(f'cond1 == cond2 = {cond1 == cond2}')

```
````
:::
::::



